package anypoint

import (
	"context"
	"fmt"
	"io"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	env "github.com/mulesoft-anypoint/anypoint-client-go/env"
)

func dataSourceENV() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceENVRead,
		Description: `
		Reads all ` + "`" + `environments` + "`" + ` in your business group.
		`,
		Schema: map[string]*schema.Schema{
			"id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The unique id of this environment generated by the anypoint platform.",
			},
			"org_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The organization id where the environment is defined.",
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The name of the environment",
			},
			"is_production": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "True if the environment is a production environment",
			},
			"type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The type of the environment: sandbox or production",
			},
			"client_id": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func dataSourceENVRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	pco := m.(ProviderConfOutput)
	envid := d.Get("id").(string)
	orgid := d.Get("org_id").(string)
	authctx := getENVAuthCtx(ctx, &pco)
	//request env
	res, httpr, err := pco.envclient.DefaultApi.OrganizationsOrgIdEnvironmentsEnvironmentIdGet(authctx, orgid, envid).Execute()
	if err != nil {
		var details string
		if httpr != nil && httpr.StatusCode >= 400 {
			defer httpr.Body.Close()
			b, _ := io.ReadAll(httpr.Body)
			details = string(b)
		} else {
			details = err.Error()
		}
		diags := append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "Unable to Get ENV",
			Detail:   details,
		})
		return diags
	}
	defer httpr.Body.Close()
	//process data
	envinstance := flattenENVData(&res)
	//save in data source schema
	if err := setENVCoreAttributesToResourceData(d, envinstance); err != nil {
		diags := append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "Unable to set ENV",
			Detail:   err.Error(),
		})
		return diags
	}

	d.SetId(envid)

	return diags
}

/*
* Copies the given env instance into the given resource data
* @param d *schema.ResourceData the resource data schema
* @param envitem map[string]interface{} the env instance
 */
func setENVCoreAttributesToResourceData(d *schema.ResourceData, envitem map[string]interface{}) error {
	attributes := getENVCoreAttributes()
	if envitem != nil {
		for _, attr := range attributes {
			if err := d.Set(attr, envitem[attr]); err != nil {
				return fmt.Errorf("unable to set ENV attribute %s\n details: %s", attr, err)
			}
		}
	}
	return nil
}

/*
* Transforms a env.Env object to the dataSourceENV schema
* @param envitem *env.Env the env struct
* @return the env mapped struct
 */
func flattenENVData(envitem *env.Env) map[string]interface{} {
	if envitem != nil {
		item := make(map[string]interface{})

		item["id"] = envitem.GetId()
		item["name"] = envitem.GetName()
		item["org_id"] = envitem.GetOrganizationId()
		item["is_production"] = envitem.GetIsProduction()
		item["type"] = envitem.GetType()
		item["client_id"] = envitem.GetClientId()

		return item
	}

	return nil
}

func getENVCoreAttributes() []string {
	attributes := [...]string{
		"name", "org_id", "is_production", "type", "client_id",
	}
	return attributes[:]
}
