package anypoint

import (
	"context"
	"fmt"
	"io"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/mulesoft-anypoint/anypoint-client-go/dlb"
)

func dataSourceDLB() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceDLBRead,
		Description: `
		Reads a specific ` + "`" + `dedicated load balancer` + "`" + ` instance.
		`,
		Schema: map[string]*schema.Schema{
			"id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The unique id of this dlb generated by the anypoint platform.",
			},
			"org_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The organization id where the dlb is defined.",
			},
			"vpc_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The vpc id",
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The name of the dlb.",
			},
			"domain": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The domain name if this dlb.",
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The desired state, possible values: 'started', 'stopped' or 'restarted'",
			},
			"deployment_id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"instance_config": {
				Type:     schema.TypeMap,
				Computed: true,
			},
			"ip_addresses": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Description: "List of static IP addresses of this dlb",
			},
			"ip_whitelist": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "CIDR blocks to allow connections from",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"ip_allowlist": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "CIDR blocks to allow connections from",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"http_mode": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Specifies whether the Load Balancer listens for HTTP requests on port 80. If set to redirect, all HTTP requests will be redirected to HTTPS. possible values: 'on', 'off' or 'redirect'",
			},
			"default_ssl_endpoint": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The default certificate that will be served for requests not using SNI, or requesting a non-existing certificate",
			},
			"ssl_endpoints": {
				Type:     schema.TypeSet,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"private_key_digest": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The private key checksum generated by the anypoint platform.",
						},
						"public_key_label": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The label of the public key.",
						},
						"public_key_digest": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The public key checksum generated by the anypoint platform.",
						},
						"public_key_cn": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The common name of the public key.",
						},
						"private_key_label": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The label of the private key.",
						},
						"client_cert_label": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The label of the client certificat.",
						},
						"client_cert_digest": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The client certificate checksum generated by the anypoint platform.",
						},
						"client_cert_cn": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The common name of the client's certificate.",
						},
						"revocation_list_label": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The label of the revocation list.",
						},
						"revocation_list_digest": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The CRL checksum generated by the anypoint platform.",
						},
						"verify_client_mode": {
							Type:        schema.TypeString,
							Description: "Whether to enable client verification or not, possible values: 'off' or 'on'",
							Computed:    true,
						},
						"mappings": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "List of dlb mappings.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"input_uri": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"app_name": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"app_uri": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"upstream_protocol": {
										Type:     schema.TypeString,
										Computed: true,
									},
								},
							},
						},
					},
				},
			},
			"static_ips_disabled": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to disable static ips for this dlb.",
			},
			"workers": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The number of workers for this dlb.",
			},
			"default_cipher_suite": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The default cipher suite used by this dlb.",
			},
			"keep_url_encoding": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to keep url encoding for this dlb.",
			},
			"tlsv1": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to activate TLS v1 for this dlb.",
			},
			"upstream_tlsv12": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to activate TLS v1.2 for this dlb upstream.",
			},
			"proxy_read_timeout": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The proxy read timeout",
			},
			"ip_addresses_info": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "List of IP addresses information of this dlb.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ip": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"status": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"static_ip": {
							Type:     schema.TypeBool,
							Computed: true,
						},
					},
				},
			},
			"double_static_ips": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "True if DLB will use double static IPs when restarting",
			},
			"enable_streaming": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Setting this to true will disable request buffering at the DLB, thereby enabling streaming",
			},
			"forward_client_certificate": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Setting this to true will forward any incoming client certificates to upstream application",
			},
		},
	}
}

func dataSourceDLBRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	pco := m.(ProviderConfOutput)
	dlbid := d.Get("id").(string)
	orgid := d.Get("org_id").(string)
	vpcid := d.Get("vpc_id").(string)
	authctx := getDLBAuthCtx(ctx, &pco)
	//request dlb
	res, httpr, err := pco.dlbclient.DefaultApi.OrganizationsOrgIdVpcsVpcIdLoadbalancersDlbIdGet(authctx, orgid, vpcid, dlbid).Execute()
	if err != nil {
		var details string
		if httpr != nil && httpr.StatusCode >= 400 {
			defer httpr.Body.Close()
			b, _ := io.ReadAll(httpr.Body)
			details = string(b)
		} else {
			details = err.Error()
		}
		diags := append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "Unable to Get DLB " + dlbid,
			Detail:   details,
		})
		return diags
	}
	defer httpr.Body.Close()
	//process data
	dlbinstance := flattenDLBData(&res)
	//save in data source schema
	if err := setDLBAttributesToResourceData(d, dlbinstance); err != nil {
		diags := append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "Unable to set DLB " + dlbid,
			Detail:   err.Error(),
		})
		return diags
	}

	d.SetId(dlbid)

	return diags
}

/*
 * Copies the given dlb instance into the given resource data
 */
func setDLBAttributesToResourceData(d *schema.ResourceData, dlbitem map[string]interface{}) error {
	attributes := getDLBAttributes()
	if dlbitem != nil {
		for _, attr := range attributes {
			if err := d.Set(attr, dlbitem[attr]); err != nil {
				return fmt.Errorf("unable to set DLB attribute %s\n details: %s", attr, err)
			}
		}
	}
	return nil
}

/*
 * Transforms a dlb.Dlb object to the dataSourceDLB schema
 */
func flattenDLBData(dlbitem *dlb.Dlb) map[string]interface{} {
	if dlbitem != nil {
		item := make(map[string]interface{})
		item["id"] = dlbitem.GetId()
		item["name"] = dlbitem.GetName()
		item["vpc_id"] = dlbitem.GetVpcId()
		item["domain"] = dlbitem.GetDomain()
		item["state"] = dlbitem.GetState()
		item["deployment_id"] = dlbitem.GetDeploymentId()
		instance_config := dlbitem.GetInstanceConfig()
		item["instance_config"] = map[string]string{
			"image_name": instance_config.GetImageName(),
		}
		item["ip_addresses"] = dlbitem.GetIpAddresses()
		item["ip_whitelist"] = dlbitem.GetIpWhitelist()
		item["ip_allowlist"] = dlbitem.GetIpAllowlist()
		item["http_mode"] = dlbitem.GetHttpMode()
		item["default_ssl_endpoint"] = dlbitem.GetDefaultSslEndpoint()
		ssl_endpoints := make([]interface{}, len(dlbitem.GetSslEndpoints()))
		for j, ssl_endpoint := range dlbitem.GetSslEndpoints() {
			s := make(map[string]interface{})
			s["private_key_digest"] = ssl_endpoint.GetPrivateKeyDigest()
			s["public_key_label"] = ssl_endpoint.GetPublicKeyLabel()
			s["public_key_digest"] = ssl_endpoint.GetPublicKeyDigest()
			s["public_key_cn"] = ssl_endpoint.GetPublicKeyCN()
			s["private_key_label"] = ssl_endpoint.GetPrivateKeyLabel()
			s["client_cert_label"] = ssl_endpoint.GetClientCertLabel()
			s["client_cert_digest"] = ssl_endpoint.GetClientCertDigest()
			s["client_cert_cn"] = ssl_endpoint.GetClientCertCN()
			s["revocation_list_label"] = ssl_endpoint.GetRevocationListLabel()
			s["revocation_list_digest"] = ssl_endpoint.GetRevocationListDigest()
			s["verify_client_mode"] = ssl_endpoint.GetVerifyClientMode()
			mappings := make([]interface{}, len(ssl_endpoint.GetMappings()))
			for k, mapping := range ssl_endpoint.GetMappings() {
				m := make(map[string]interface{})
				m["input_uri"] = mapping.GetInputUri()
				m["app_name"] = mapping.GetAppName()
				m["app_uri"] = mapping.GetAppUri()
				m["upstream_protocol"] = mapping.GetUpstreamProtocol()
				mappings[k] = m
			}
			s["mappings"] = mappings
			ssl_endpoints[j] = s
		}
		item["ssl_endpoints"] = ssl_endpoints
		item["static_ips_disabled"] = dlbitem.GetStaticIPsDisabled()
		item["workers"] = dlbitem.GetWorkers()
		item["default_cipher_suite"] = dlbitem.GetDefaultCipherSuite()
		item["keep_url_encoding"] = dlbitem.GetKeepUrlEncoding()
		item["tlsv1"] = dlbitem.GetTlsv1()
		item["upstream_tlsv12"] = dlbitem.GetUpstreamTlsv12()
		item["proxy_read_timeout"] = dlbitem.GetProxyReadTimeout()
		ip_addresses_info := make([]interface{}, len(dlbitem.GetIpAddressesInfo()))
		for j, ip_address_info := range dlbitem.GetIpAddressesInfo() {
			info := make(map[string]interface{})
			info["ip"] = ip_address_info.GetIp()
			info["status"] = ip_address_info.GetStatus()
			info["static_ip"] = ip_address_info.GetStaticIp()
			ip_addresses_info[j] = info
		}
		item["ip_addresses_info"] = ip_addresses_info
		item["double_static_ips"] = dlbitem.GetDoubleStaticIps()
		item["enable_streaming"] = dlbitem.GetEnableStreaming()
		item["forward_client_certificate"] = dlbitem.GetForwardClientCertificate()
		return item
	}

	return nil
}

// func getDLBCoreAttributes() []string {
// 	attributes := [...]string{
// 		"name", "state", "ip_whitelist", "ip_allowlist", "http_mode", "default_ssl_endpoint",
// 		"tlsv1", "ssl_endpoints", "upstream_tlsv12", "keep_url_encoding", "double_static_ips", "enable_streaming",
// 		"forward_client_certificate",
// 	}
// 	return attributes[:]
// }

func getDLBAttributes() []string {
	attributes := [...]string{
		"id", "vpc_id", "name", "domain", "state", "deployment_id", "instance_config",
		"ip_addresses", "ip_whitelist", "http_mode", "default_ssl_endpoint",
		"ssl_endpoints", "static_ips_disabled", "workers", "default_cipher_suite",
		"keep_url_encoding", "tlsv1", "upstream_tlsv12", "proxy_read_timeout",
		"ip_addresses_info", "double_static_ips", "ip_allowlist", "enable_streaming",
		"forward_client_certificate",
	}
	return attributes[:]
}
