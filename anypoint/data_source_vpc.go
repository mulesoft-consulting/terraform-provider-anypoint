package anypoint

import (
	"context"
	"fmt"
	"io"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	vpc "github.com/mulesoft-anypoint/anypoint-client-go/vpc"
)

func dataSourceVPC() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceVPCRead,
		Description: `
		Reads a specific ` + "`" + `vpc` + "`" + ` in the business group.
		`,
		Schema: map[string]*schema.Schema{
			"id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The unique id of this vpc generated by the anypoint platform.",
			},
			"org_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The organization id where the vpc is defined.",
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The name of the vpc.",
			},
			"region": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The CloudHub region where this VPC will exist",
			},
			"cidr_block": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The IP address range that the VPC will use. The largest is /16 and the smallest, /24",
			},
			"internal_dns_servers": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Description: "List of internal dns servers",
			},
			"internal_dns_special_domains": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Description: "List of internal dns special domains",
			},
			"is_default": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "If set to true, the VPC will be associated to all CloudHub environments not explicitly associated to another VPC, including newly created ones",
			},
			"associated_environments": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Description: "A list of CloudHub environments to associate to this VPC",
			},
			"owner_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: "The id of the organization that owns the VPC",
			},
			"shared_with": {
				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Description: "A list of Business Groups to share this VPC with",
			},
			"firewall_rules": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Inbound firewall rules for all CloudHub workers in this VPC. The list is allow only with an implicit deny all if no rules match",

				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cidr_block": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"protocol": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"from_port": {
							Type:     schema.TypeInt,
							Computed: true,
						},
						"to_port": {
							Type:     schema.TypeInt,
							Computed: true,
						},
					},
				},
			},
			"vpc_routes": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "The network routes of this VPC.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"next_hop": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"cidr": {
							Type:     schema.TypeString,
							Computed: true,
						},
					},
				},
			},
		},
	}
}

func dataSourceVPCRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	// Warning or errors can be collected in a slice type
	var diags diag.Diagnostics
	pco := m.(ProviderConfOutput)
	vpcid := d.Get("id").(string)
	orgid := d.Get("org_id").(string)
	authctx := getVPCAuthCtx(ctx, &pco)
	//request vpcs
	res, httpr, err := pco.vpcclient.DefaultApi.OrganizationsOrgIdVpcsVpcIdGet(authctx, orgid, vpcid).Execute()
	if err != nil {
		var details string
		if httpr != nil && httpr.StatusCode >= 400 {
			defer httpr.Body.Close()
			b, _ := io.ReadAll(httpr.Body)
			details = string(b)
		} else {
			details = err.Error()
		}
		diags := append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "Unable to get VPC " + vpcid,
			Detail:   details,
		})
		return diags
	}
	defer httpr.Body.Close()
	//process data
	vpcinstance := flattenVPCData(&res)
	//save in data source schema
	if err := setVPCCoreAttributesToResourceData(d, vpcinstance); err != nil {
		diags := append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "Unable to set VPC " + vpcid,
			Detail:   err.Error(),
		})
		return diags
	}

	d.SetId(vpcid)

	return diags
}

/*
* Copies the given vpc instance into the given resource data
* @param d *schema.ResourceData the resource data schema
* @param vpcitem map[string]interface{} the vpc instance
 */
func setVPCCoreAttributesToResourceData(d *schema.ResourceData, vpcitem map[string]interface{}) error {
	attributes := getVPCCoreAttributes()
	if vpcitem != nil {
		for _, attr := range attributes {
			if err := d.Set(attr, vpcitem[attr]); err != nil {
				return fmt.Errorf("unable to set VPC attribute %s\n details: %s", attr, err)
			}
		}
	}
	return nil
}

/*
* Transforms a vpc.Vpc object to the dataSourceVPC schema
* @param vpcitem *vpc.Vpc the vpc struct
* @return the vpc mapped struct
 */
func flattenVPCData(vpcitem *vpc.Vpc) map[string]interface{} {
	if vpcitem != nil {
		item := make(map[string]interface{})

		item["id"] = vpcitem.GetId()
		item["name"] = vpcitem.GetName()
		item["region"] = vpcitem.GetRegion()
		item["cidr_block"] = vpcitem.GetCidrBlock()
		item["internal_dns_servers"] = vpcitem.GetInternalDns().DnsServers
		item["internal_dns_special_domains"] = vpcitem.GetInternalDns().SpecialDomains
		item["is_default"] = vpcitem.GetIsDefault()
		item["associated_environments"] = vpcitem.GetAssociatedEnvironments()
		item["owner_id"] = vpcitem.GetOwnerId()
		item["shared_with"] = vpcitem.GetSharedWith()

		frules := make([]interface{}, len(vpcitem.GetFirewallRules()))
		for j, frule := range vpcitem.GetFirewallRules() {
			r := make(map[string]interface{})
			r["cidr_block"] = frule.GetCidrBlock()
			r["protocol"] = frule.GetProtocol()
			r["from_port"] = frule.GetFromPort()
			r["to_port"] = frule.GetToPort()
			frules[j] = r
		}
		item["firewall_rules"] = frules

		vpcroutes := make([]interface{}, len(vpcitem.GetVpcRoutes()))
		for j, vpcroute := range vpcitem.GetVpcRoutes() {
			r := make(map[string]interface{})
			r["next_hop"] = vpcroute.GetNextHop()
			r["cidr"] = vpcroute.GetCIDR()
			vpcroutes[j] = r
		}
		item["vpc_routes"] = vpcroutes
		return item
	}

	return nil
}

func getVPCCoreAttributes() []string {
	attributes := [...]string{
		"name", "region", "cidr_block", "internal_dns_servers", "internal_dns_special_domains",
		"is_default", "associated_environments", "owner_id", "shared_with", "firewall_rules", "vpc_routes",
	}
	return attributes[:]
}
